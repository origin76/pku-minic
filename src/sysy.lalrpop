use crate::ast::*;
use std::boxed::Box;
use koopa::ir::BinaryOp;


// lalrpop 里的约定
grammar;

Comma<T>: Vec<T> = {
    <h:T> <t:("," <T>)*> => {
        let mut v = vec![h];
        v.extend(t);
        v
    },
    => vec![],
};

// 约束 lexer 的行为
match {
    // 跳过空白符和单行注释
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    // 处理块注释
    r"/\*([^*]|\*+[^*/])*\*+/" => {},
    // 剩下的情况采用默认方式处理
    _
}

pub CompUnit: CompUnit = <funcs:FuncDef*> => CompUnit { func_defs: funcs };

pub FuncDef: FuncDef = {
    <t:Type> <id:Ident> "(" <params:Comma<FuncFParam>> ")" <b:Block> => FuncDef {
        func_type: t,
        ident: id,
        params: params,
        block: b,
    }
}

// FuncFParam ::= BType IDENT;
FuncFParam: FuncFParam = {
    <t:Type> <id:Ident> => FuncFParam {
        b_type: t,
        ident: id,
    }
}

Type: Type = {
    "void" => Type::Void,
    "int" => Type::Int,
}

Block: Block = "{" <items:BlockItem*> "}" => Block { items };

BlockItem: BlockItem = {
    <d:Decl> => BlockItem::Decl(d),
    <s:Stmt> => BlockItem::Stmt(s),
}

Decl: Decl = {
    <c:ConstDecl> => Decl::ConstDecl(c),
    <v:VarDecl> => Decl::VarDecl(v),
}

// 变量声明规则
// VarDecl ::= BType VarDef {"," VarDef} ";";
VarDecl: VarDecl = {
    <t:Type> <defs:Comma<VarDef>> ";" => VarDecl {
        b_type: t,
        defs: defs,
    }
}

// 变量定义规则
// VarDef ::= IDENT | IDENT "=" InitVal;
VarDef: VarDef = {
    <id:Ident> <init:("=" <Exp>)?> => VarDef {
        ident: id,
        init: init, // init 是 Option<Box<Exp>>
    }
}

ConstDecl: ConstDecl = {
    "const" <t:Type> <defs:Comma<ConstDef>> ";" => ConstDecl {
        b_type: t,
        defs: defs,
    }
}

// ConstDef ::= IDENT "=" ConstInitVal;
ConstDef: ConstDef = {
    <id:Ident> "=" <v:ConstInitVal> => ConstDef {
        ident: id,
        init: v,
    }
}

// ConstInitVal ::= ConstExp;
ConstInitVal: Box<Exp> = ConstExp;

// ConstExp ::= Exp;
ConstExp: Box<Exp> = Exp;

// =====================================
// 语句 Stmt (入口)
// =====================================

// Stmt 包含所有情况
pub Stmt: Stmt = {
    MatchedStmt,
    OpenStmt,
}

// =====================================
// 1. MatchedStmt (闭合语句)
// 这些语句要么没有 if，要么 if 配备了 else，且 else 后面也是闭合的
// =====================================
MatchedStmt: Stmt = {
    // 情况 A: 非 If 语句 (本身就是闭合的)
    <l:LVal> "=" <e:Exp> ";" => Stmt::Assign(l, e),
    <e:Exp?> ";" => Stmt::Exp(e),
    <b:Block> => Stmt::Block(b),
    "return" <e:Exp?> ";" => Stmt::Return(e),

    // 情况 B: 完整的 If-Else (要求两个分支都是 Matched)
    // 这里的 "else" <MatchedStmt> 强制了内层必须闭合，消除了歧义
    "if" "(" <cond:Exp> ")" <then_stmt:MatchedStmt> "else" <else_stmt:MatchedStmt> => {
        Stmt::If(cond, Box::new(then_stmt), Some(Box::new(else_stmt)))
    },
    "while" "(" <cond:Exp> ")" <s:MatchedStmt> => {
        Stmt::While(cond, Box::new(s))
    },
    "break" ";" => Stmt::Break,
    "continue" ";" => Stmt::Continue,
}

// =====================================
// 2. OpenStmt (开放语句)
// 这些语句以一个没有 else 的 if 结尾 (悬挂)
// =====================================
OpenStmt: Stmt = {
    // 情况 A: 只有一个 If，没有 Else
    // 注意：这里的子语句可以是任意 Stmt (Matched 或 Open 均可)
    "if" "(" <cond:Exp> ")" <then_stmt:Stmt> => {
        Stmt::If(cond, Box::new(then_stmt), None)
    },

    // 情况 B: 有 Else，但 Else 分支本身是 Open 的
    // 注意：then 分支必须是 MatchedStmt！这是消除歧义的关键！
    // 如果 then 分支是 Open 的 (例如 if (a) if (b) s)，那么 else 就会被解析给内层的 if
    "if" "(" <cond:Exp> ")" <then_stmt:MatchedStmt> "else" <else_stmt:OpenStmt> => {
        Stmt::If(cond, Box::new(then_stmt), Some(Box::new(else_stmt)))
    },

    "while" "(" <cond:Exp> ")" <s:OpenStmt> => {
        Stmt::While(cond, Box::new(s))
    },
}

// =====================================
// 层级 1: 逻辑或 (||) - 优先级最低
// 对应 BNF: LOrExp ::= LAndExp | LOrExp "||" LAndExp;
// =====================================
pub Exp: Box<Exp> = LOrExp; // 入口指向 LOrExp

LOrExp: Box<Exp> = {
    <l:LOrExp> "||" <r:LAndExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Or, r)),
    LAndExp, // 降级
}

// =====================================
// 层级 2: 逻辑与 (&&)
// 对应 BNF: LAndExp ::= EqExp | LAndExp "&&" EqExp;
// =====================================
LAndExp: Box<Exp> = {
    <l:LAndExp> "&&" <r:EqExp> => Box::new(Exp::BinaryExp(l, BinaryOp::And, r)),
    EqExp,
}

// =====================================
// 层级 3: 相等性 (==, !=)
// 对应 BNF: EqExp ::= RelExp | EqExp ("==" | "!=") RelExp;
// =====================================
EqExp: Box<Exp> = {
    <l:EqExp> "==" <r:RelExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Eq, r)),
    <l:EqExp> "!=" <r:RelExp> => Box::new(Exp::BinaryExp(l, BinaryOp::NotEq, r)),
    RelExp,
}

// =====================================
// 层级 4: 关系比较 (<, >, <=, >=)
// 对应 BNF: RelExp ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
// =====================================
RelExp: Box<Exp> = {
    <l:RelExp> "<"  <r:AddExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Lt, r)),
    <l:RelExp> ">"  <r:AddExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Gt, r)),
    <l:RelExp> "<=" <r:AddExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Le, r)),
    <l:RelExp> ">=" <r:AddExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Ge, r)),
    AddExp,
}

// =====================================
// 层级 5: 加减法 (+, -)
// 对应 BNF: AddExp ::= MulExp | AddExp ("+" | "-") MulExp;
// =====================================
AddExp: Box<Exp> = {
    <l:AddExp> "+" <r:MulExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Add, r)),
    <l:AddExp> "-" <r:MulExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Sub, r)),
    MulExp,
}

// =====================================
// 层级 6: 乘除模 (*, /, %)
// 对应 BNF: MulExp ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
// =====================================
MulExp: Box<Exp> = {
    <l:MulExp> "*" <r:UnaryExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Mul, r)),
    <l:MulExp> "/" <r:UnaryExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Div, r)),
    <l:MulExp> "%" <r:UnaryExp> => Box::new(Exp::BinaryExp(l, BinaryOp::Mod, r)),
    UnaryExp,
}

// =====================================
// 层级 7: 一元运算 (+, -, !)
// 对应 BNF: UnaryExp ::= PrimaryExp | UnaryOp UnaryExp;
// =====================================
UnaryExp: Box<Exp> = {
    <id:Ident> "(" <args:Comma<Exp>> ")" => Box::new(Exp::FuncCall(id, args)),
    // 递归调用 UnaryExp 以支持右结合 (如 - - 5)
    <op:UnaryOp> <e:UnaryExp> => Box::new(Exp::UnaryExp(op, e)),
    // 降级到 PrimaryExp，需要包装成 Exp 类型
    <p:PrimaryExp> => Box::new(Exp::PrimaryExp(p)),
}

// =====================================
// 层级 8: 基础表达式 (数值, 括号) - 优先级最高
// =====================================
PrimaryExp: Box<PrimaryExp> = {
    "(" <e:Exp> ")" => Box::new(PrimaryExp::Parentheses(e)),
    <l:LVal> => Box::new(PrimaryExp::LVal(l)),    // 新增: 匹配左值
    <n:Number> => Box::new(PrimaryExp::Number(n)), // 匹配数字
}

// LVal ::= IDENT;
LVal: LVal = {
    <id:Ident> => LVal { ident: id }
}


UnaryOp: UnaryOp = {
  "+" => UnaryOp::Plus,
  "-" => UnaryOp::Minus,
  "!" => UnaryOp::Not,
};


Number: i32 = <num: IntConst> => <>;

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

// 对整数字面量的处理方式: 把匹配到的字符串按对应进制转换成数字
IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}
